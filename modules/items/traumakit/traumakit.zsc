#include "modules/items/traumakit/traumakit_painkiller.zsc"
#include "modules/items/traumakit/traumakit_forceps.zsc"
#include "modules/items/traumakit/traumakit_stapler.zsc"
#include "modules/items/traumakit/traumakit_sutures.zsc"
#include "modules/items/traumakit/traumakit_biofoam.zsc"
//#include "modules/items/traumakit/traumakit_2f.zsc"
#include "modules/items/traumakit/traumakit_saline.zsc"

class UaS_TraumaKit : HDWeapon {
	string statusMessage;
	StatusInfo currentMessage;
	WoundInfo currentWound;
	UaS_WoundHandler wh;

	Default {
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Picked up a personal trauma kit.";
		Inventory.Icon "ROCKA0";
		+INVENTORY.INVBAR;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.IGNORESKILL;
		+WEAPON.NO_AUTO_SWITCH;
		//+WEAPON.NOAUTOFIRE;
	}
	override double weaponbulk(){ return 20; }

	override void DoEffect() {
		if (!(owner.player.readyweapon is 'UaS_TraumaKit')) { return; }
		if (!wh) { wh = UaS_WoundHandler(owner.FindInventory('UaS_WoundHandler')); }
		if (!wh) { console.printf("No wound handler!"); return; }

		statusMessage = "\cyTrauma Kit\n\n";

		WoundList();
		CycleWounds();
		CycleTools();

		switch (weaponstatus[TK_SELECTED]) {
			case T_PAINKILLER:
				HandlePainkiller();
				break;
			case T_SALINE:
				HandleSaline();
				break;
			case T_FORCEPS:
				HandleForceps();
				break;
			case T_BIOFOAM:
				HandleBiofoam();
				break;
			case T_STAPLER:
				HandleStapler();
				break;
			case T_SUTURES:
				HandleSutures();
				break;
			/*case T_2F: //Maybe add later
				Handle2F();
				break;*/
		}

		// Debugging
		if (currentWound) {
			statusmessage = statusmessage..currentWound.AverageStatus().."\n";
			statusmessage = statusmessage.."dirty "..currentWound.dirty.."\n";
			statusmessage = statusmessage.."obstructed "..currentWound.obstructed.."\n";
			statusmessage = statusmessage.."open "..currentWound.open.."\n";
			statusmessage = statusmessage.."cavity "..currentWound.cavity.."\n";
			statusmessage = statusmessage.."infection "..currentWound.infection.."\n";
			statusmessage = statusmessage.."timer "..currentWound.timer.."\n";
		}

		// Tick down transient messages
		if (currentmessage.timeout > 0) {
			statusmessage = statusmessage..currentmessage.text;
			currentmessage.timeout--;
		}

		A_WeaponMessage(statusMessage);
	}

	void WoundList() {
		if (wh.critwounds.size() == 0) {
			statusmessage = statusmessage.."No treatable wounds\n\n";
			return;
		}
		int loopmin = min(weaponstatus[TK_WOUNDINDEX] - 2, wh.critwounds.size() - 5);
		int loopmax = max(weaponstatus[TK_WOUNDINDEX] + 2, 4);
		if (loopmin > 0) { statusmessage = statusmessage..". . .\n"; }
		else { statusmessage = statusmessage.."\n"; }
		for (int i = loopmin; i <= loopmax; i++) {
			if(i<0 || i > wh.critwounds.size()-1) { continue; }
			string hilite;
			if (currentWound == wh.critwounds[i]) {
				if (wh.critwounds[i].AverageStatus() >= 10) { hilite = "\ca"; }
				else { hilite = "\cd"; }
			}
			else {
				if (wh.critwounds[i].AverageStatus() >= 10) { hilite = "\cr"; }
 				else { hilite = "\cq"; }
 			}
			statusmessage = statusmessage..hilite..wh.critwounds[i].description.."\n";
		}
		if (loopmax < wh.critwounds.size() - 1) { statusmessage = statusmessage..". . .\n"; }
		else { statusmessage = statusmessage.."\n"; }
		statusmessage = statusmessage.."\n";
	}

	void CycleWounds() {
		if (!currentWound) { weaponstatus[TK_WOUNDINDEX] = -1; }
		if (wh.critwounds.size() == 0) { return; }
		if ((owner.player.cmd.buttons & BT_RELOAD) && !(owner.player.oldbuttons & BT_RELOAD)) {
			weaponstatus[TK_WOUNDINDEX] = (weaponstatus[TK_WOUNDINDEX] + 1) % wh.critwounds.size();
			currentWound = GetWound(weaponstatus[TK_WOUNDINDEX]);
		}
		if ((owner.player.cmd.buttons & BT_ALTRELOAD) && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			weaponstatus[TK_WOUNDINDEX] = (weaponstatus[TK_WOUNDINDEX] - 1) % wh.critwounds.size();
			if(weaponstatus[TK_WOUNDINDEX] < 0) { weaponstatus[TK_WOUNDINDEX] = wh.critwounds.size() - 1; }
			currentWound = GetWound(weaponstatus[TK_WOUNDINDEX]);
		}
	}

	void CycleTools() {
		if ((owner.player.cmd.buttons & BT_USER2) && !(owner.player.oldbuttons & BT_USER2)) {
			weaponstatus[TK_SELECTED] = (weaponstatus[TK_SELECTED] + 1) % 6;
			weaponstatus[TK_HOLD] = 0;
			currentmessage.text = "";
			currentmessage.timeout = 0;
		}
	}

	WoundInfo GetWound(int index) {
		if (wh.critwounds.size() <= 0) { return null; }
		return wh.critwounds[index];
	}

	void DebugStatus() {
		if (!owner) { return; }
		let ownr = HDPlayerPawn(owner);
		statusMessage = statusMessage.."\n";
		statusMessage = statusMessage.."Open Wounds "..ownr.woundcount.."\n";
		statusMessage = statusMessage.."Unstable Wounds "..ownr.unstablewoundcount.."\n";
		statusMessage = statusMessage.."Old Wounds "..ownr.oldwoundcount.."\n";
	}

	struct StatusInfo {
		string text;
		int timeout;
	}

	enum ToolModes {
		T_PAINKILLER,
		T_SALINE,
		T_FORCEPS,
		T_BIOFOAM,
		T_STAPLER,
		T_SUTURES,
		T_2F,
	}

	enum KitFlags {
		TK_SELECTED,
		TK_BUTTON,
		TK_HOLD,
		TK_WOUNDINDEX
	}
}
