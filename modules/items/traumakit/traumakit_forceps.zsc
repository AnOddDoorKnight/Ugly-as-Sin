extend class UaS_TraumaKit {
	bool holdingopen;
	int mashes;

	void HandleForceps() {
		statusMessage = statusmessage.."\cjForceps\n";
		statusMessage = statusmessage.."\cuPrecision tool for removing obstructions.\n\n";
		if (!currentWound) { return; }
		if (currentWound.open <= 0) { return; }

		// Handle actions

		// player must release buttons
		if (!(owner.player.oldbuttons & BT_ATTACK)) { weaponstatus[TK_HOLD] = 0; holdingopen = false; mashes = 0; }
		// otherwise force abort
		if (weaponstatus[TK_HOLD] < 0) { return; }

		// Hold wound open
		if ((owner.player.cmd.buttons & BT_ATTACK)) {
			weaponstatus[TK_HOLD]++;
			holdingopen = true;
			currentmessage.text = "Holding the wound open.\n";
			currentmessage.timeout = 5;
			double shake = weaponstatus[TK_HOLD];
			if (currentWound.numb()) { shake *= 0.001; }
			else { shake *= 0.01; }
			HDPlayerPawn(owner).A_MuzzleClimb(
				(frandom[uas_tk](-shake,shake),frandom[uas_tk](-shake,shake)),
				(frandom[uas_tk](-shake,shake),frandom[uas_tk](-shake,shake)),
				(frandom[uas_tk](-shake,shake),frandom[uas_tk](-shake,shake)),
				(frandom[uas_tk](-shake,shake),frandom[uas_tk](-shake,shake))
			);
		}

		// Abort if too much pain
		int threshold = random[uas_tk](100,200);
		if (currentWound.numb()) { threshold *= 4; }
		if (weaponstatus[TK_HOLD] > threshold) {
			weaponstatus[TK_HOLD] = -1;
			holdingopen = false;
			PainJolt();
			return;
		}

		for (int i = 0; i < mashes; i++) { currentmessage.text = currentmessage.text.."."; }

		// Extract fragments
		if ((owner.player.cmd.buttons & BT_UNLOAD) && !(owner.player.oldbuttons & BT_UNLOAD)) {
			mashes++;
			owner.A_StartSound("misc/smallslop",CHAN_BODY);
			if (!currentWound.numb()) {
				weaponstatus[TK_HOLD] = -1;
				holdingopen = false;
				mashes = 0;
				PainJolt();
				return;
			}
			if(random[uas_tk](0,1)) { owner.A_StartSound("*grunt",CHAN_VOICE); }
			HDPlayerPawn(owner).A_MuzzleClimb(
				(frandom[uas_tk](-1,1),frandom[uas_tk](-1,1)),
				(frandom[uas_tk](-1,1),frandom[uas_tk](-1,1)),
				(frandom[uas_tk](-1,1),frandom[uas_tk](-1,1)),
				(frandom[uas_tk](-3,3),frandom[uas_tk](-3,3)));
			int check = (
				random[uas_tk](100,200) +
				random[uas_tk](100,200)) / 2;

			if (check <= weaponstatus[TK_HOLD] || check <= mashes * 20) {
				weaponstatus[TK_HOLD] = 50;
				int remove = frandom[uas_tk](2,4) * mashes;
				string result;

				if (currentWound.obstructed > 0) { result = ExtractionMessage(); }
				else { result = "You yank at the wound ineffectually"; }

				// increase cavity on overshoot
				if (remove > currentWound.obstructed) {
					currentWound.cavity = min(currentWound.cavity + (remove / 2), 100);
					result = result..", damaging the surrounding tissue.";
				}
				else {
					result = result..".";
				}

				currentWound.obstructed = max(currentWound.obstructed - remove, 0);
				owner.A_StartSound("misc/bulletflesh",CHAN_BODY);
				owner.damagemobj(owner,owner,1,"staples");
				owner.A_Log(result, true);
				mashes = 0;
			}
		}
	}
}

extend class UaS_TraumaKit {
	string ExtractionMessage(bool damage = false) {
		string r;
		r = string.format("You %s %s %s out of the wound",
			UaS_TraumaKit.verb[random[uas_tk](0,UaS_TraumaKit.verb.size()-1)],
			UaS_TraumaKit.piece[random[uas_tk](0,UaS_TraumaKit.verb.size()-1)],
			UaS_TraumaKit.material[random[uas_tk](0,UaS_TraumaKit.verb.size()-1)]
		);
		return r;
	}

	static const string[] verb = {
		"pull",
		"yank",
		"jerk",
		"tug",
		"extract",
		"fish",
		"carefully remove"
	};
	static const string[] piece = {
		"a sliver of",
		"a chunk of",
		"a piece of",
		"a fragment of",
		"a shard of",
		"some slivers of",
		"some chunks of",
		"some pieces of",
		"some fragments of",
		"some shards of"
	};
	static const string[] material = {
		"bone",
		"shrapnel",
		"metal",
		"claw",
		"tooth",
		"plastic",
		"a bullet",
		"a hollowpoint jacket",
		"lead",
		"copper",
		"brass",
		"necrotic tissue"
	};
}
