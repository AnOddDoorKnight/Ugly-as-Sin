class WoundInfo {
	string description;
	bool numb;
	int dirty;
	int septic;
	int obstructed;
	int open;
	int timer;
	int size;

	static WoundInfo create(int newsize) {
		WoundInfo nw = new("WoundInfo");
		nw.numb = false;
		nw.dirty = random(newsize * 5, 100);
		nw.septic = random(newsize * 5, 100);
		nw.obstructed = random(newsize * 5, 100);
		nw.open = random(newsize * 5, 100);
		nw.timer = -1;
		nw.size = newsize;
		nw.description = WoundDescription(newsize);
		return nw;
	}

	static string WoundDescription(int newsize) {
		int sevmax = WoundInfo.severity.size()-1;
		int typmax = WoundInfo.type.size()-1;
		int locmax = WoundInfo.location.size()-1;
		int parmax = WoundInfo.bodypart.size()-1;
		return string.format("%s %s, %s %s",
			WoundInfo.severity[min(random(newsize, sevmax), sevmax)],
			WoundInfo.type[random(0, typmax)],
			WoundInfo.location[random(0, locmax)],
			WoundInfo.bodypart[random(0, parmax)]
		);
	}

	static const string[] severity = { "minor","small","superficial","moderate","medium","large","serious","critical" };
	static const string[] type = { "incision","laceration","puncture","avulsion","penetration" };
	static const string[] location = { "left","right" };
	static const string[] bodypart = { "upper leg","lower leg","upper arm","lower arm","shoulder","hip","upper torso","lower torso" };
}

class UaS_WoundHandler : Inventory {
	int lastwounds;
	double woundaverage;
	array<WoundInfo> critwounds;

	default {
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.UNDROPPABLE;
		-INVENTORY.INVBAR;
		+INVENTORY.UNTOSSABLE;
	}

	override void DoEffect() {
		if (!owner) { return; }
		ManageWounds();
		//TODO: Tick down wounds that have healing timers
		//TickWounds()
	}

	void ManageWounds() {
		HDPlayerPawn plr = HDPlayerPawn(owner);

		// get difference from last tick
		int diffwounds = max(plr.oldwoundcount,0) - lastwounds; // gotta clamp this to avoid false positives

		if (diffwounds > 0) { // add new stable wounds
			console.printf("new wound added at tick "..level.maptime);
			critwounds.push(WoundInfo.Create(diffwounds));
			DebugWoundList();
		}
		else if (diffwounds < 0) { // remove a passively-healed wound
			console.printf("old wound removed at tick "..level.maptime);
			critwounds.delete(0);
			DebugWoundList();
		}

		// sync count for next tick
		lastwounds = max(plr.oldwoundcount, 0); // gotta clamp this to avoid false positives
	}

	void DebugWoundList() {
		for (int i = 0; i <= critwounds.size() - 1; i++) {
			console.printf("W"..i..": "..critwounds[i].description);
		}
	}
}

class UaS_TraumaKit : HDWeapon {
	struct StatusInfo {
		string Message;
		int timout;
	}

	enum ToolModes {
		T_PAINKILLER,
		T_FORCEPS,
		T_SALINE,
		T_BIOFOAM,
		T_STAPLER,
		T_SUTURES,
		T_2F,
	}

	int currentTool;
	string statusMessage, currentMessage;

	Default {
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Picked up a personal trauma.";
		Inventory.Icon "ROCKA0";
		+INVENTORY.INVBAR;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.IGNORESKILL;
		+WEAPON.NO_AUTO_SWITCH;
		//+WEAPON.NOAUTOFIRE;
	}

	override void DoEffect() {
		// Cycle tools
		if ((owner.player.cmd.buttons & BT_USER2) && !(owner.player.oldbuttons & BT_USER2)) {
			currentTool++;
			if (CurrentTool > T_2F) { CurrentTool = T_PAINKILLER; }
		}

		// Status messages
		statusMessage = "\cyField Medical Kit\n\n";
		switch (currentTool) {
			case T_PAINKILLER:
				statusMessage = statusmessage.."\cjAnaesthetic\n";
				statusMessage = statusmessage.."\cuFast-acting local painkiller.\n";
				break;
			case T_FORCEPS:
				statusMessage = statusmessage.."\cjForceps\n";
				statusMessage = statusmessage.."\cuPrecision tool for removing obstructions..\n";
				break;
			case T_SALINE:
				statusMessage = statusmessage.."\cjSaline\n";
				statusMessage = statusmessage.."\cuSterile flushing/cleaning solution.\n";
				break;
			case T_BIOFOAM:
				statusMessage = statusmessage.."\cjBiofoam\n";
				statusMessage = statusmessage.."\cuAbsorbant antispetic flesh-analogue.\n";
				break;
			case T_STAPLER:
				statusMessage = statusmessage.."\cjStapler\n";
				statusMessage = statusmessage.."\cuManual hand-stapler.\n";
				break;
			case T_SUTURES:
				statusMessage = statusmessage.."\cjSutures\n";
				statusMessage = statusmessage.."\cuHook needle and biodegradable thread.\n";
				break;
			case T_2F:
				statusMessage = statusmessage.."\cjSecond Flesh\n";
				statusMessage = statusmessage.."\cuAdvanced stem cell and nutrient cocktail.\n";
				break;
		}

		statusMessage = statusMessage.."\n\n\n\n";
		statusMessage = statusMessage.."\crTreating:\n";
		DebugStatus();

		A_WeaponMessage(statusMessage);
	}

	void DebugStatus() {
		if (!owner) { return; }
		let ownr = HDPlayerPawn(owner);
		statusMessage = statusMessage.."\n"..currentMessage;
		statusMessage = statusMessage.."Open Wounds "..ownr.woundcount.."\n";
		statusMessage = statusMessage.."Unstable Wounds "..ownr.unstablewoundcount.."\n";
		statusMessage = statusMessage.."Old Wounds "..ownr.oldwoundcount.."\n";
	}
}
