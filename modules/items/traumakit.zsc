class WoundInfo {
	bool obstructed;
	bool numb;
	bool clean;
	bool open;
	string description;

	static WoundInfo create() {
		WoundInfo newWound = new("WoundInfo");
		newWound.obstructed = random(false,true);
		newWound.numb = false;
		newWound.clean = false;
		newWound.open = false;
		newWound.description = string.format("%s %s, %s %s",
			WoundInfo.severity[random(0, WoundInfo.severity.size()-1)],
			WoundInfo.type[random(0, WoundInfo.type.size()-1)],
			WoundInfo.location[random(0, WoundInfo.location.size()-1)],
			WoundInfo.bodypart[random(0, WoundInfo.bodypart.size()-1)]
		);
		return newWound;
	}

	static const string[] location = { "left","right" };
	static const string[] bodypart = { "upper leg","lower leg","upper arm","lower arm","shoulder","hip","upper torso","lower torso" };
	static const string[] severity = { "minor","small","superficial","moderate","medium","large","serious" };
	static const string[] type = { "incision","laceration","puncture","avulsion","penetration" };
}

class UaS_WoundHandler : Inventory {
	int lastwounds;
	double woundaverage;
	array<WoundInfo> critwounds;

	default {
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.UNDROPPABLE;
		-INVENTORY.INVBAR;
		+INVENTORY.UNTOSSABLE;
	}

	override void DoEffect() {
		if (!owner) { return; }
		CheckForNewWounds();
		ClampWounds();
	}

	void ClampWounds() {
		HDPlayerPawn plr = HDPlayerPawn(owner);
		int clampopen;
		for (int i = 0; i < critwounds.size(); i++) {
			if (critwounds[i].open) { clampopen++; }
		}
		plr.unstablewoundcount = max(plr.unstablewoundcount, critwounds.size());
		plr.woundcount = max(plr.woundcount, clampopen);
	}

	void CheckForNewWounds() {
		HDPlayerPawn plr = HDPlayerPawn(owner);

		// get new wounds and average rolling
		int newwounds = plr.woundcount - lastwounds;
		woundaverage = (woundaverage * 0.75) + newwounds;
		lastwounds = plr.woundcount;

		if (woundaverage >= random[wounding](1, 3)) {
			critwounds.push(WoundInfo.Create());
			woundaverage *= 0.5;
			int lastwoundindex = critwounds.size() - 1;
			console.printf(critwounds[lastwoundindex].description);
		}
	}
}

/*class UaS_FieldSurgeryKit : HDWeapon {
	struct StatusInfo {
		string Message;
		int timout;
	}

	enum ToolModes {
		T_PAINKILLER,
		T_FORCEPS,
		T_SALINE,
		T_BIOFOAM,
		T_STAPLER,
		T_SUTURES,
		T_2F,
	}

	string statusMessage, currentMessage;

	Default {
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Picked up a portable field surgery kit.";
		Inventory.Icon "ROCKA0";
		Scale 0.5;
		+INVENTORY.INVBAR;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.IGNORESKILL;
		+WEAPON.NO_AUTO_SWITCH;
		//+WEAPON.NOAUTOFIRE;
	}

	override void DoEffect() {
		let o = HDPlayerPawn(owner);
		if (!o) { return; }

		// Maintain wound states appropriately
		bool kitOpen = (owner.player.readyweapon.GetClassName() == "UaS_FieldSurgeryKit");
		switch (kitOpen) {
			case true:
				o.woundCount = max(currentWound.size, o.woundCount);
				break;
			case false:
				currentWound.size = min(currentWound.size, o.woundCount);
				if (currentWound.size <=0) { currentwound.active = false; }
				return;
				break;
		}

		// Cycle tools
		if ((owner.player.cmd.buttons & BT_USER2) && !(owner.player.oldbuttons & BT_USER2)) {
			currentTool++;
			if (CurrentTool > T_2F) { CurrentTool = T_PAINKILLER; }
		}

		// Status messages
		statusMessage = "\cyField Medical Kit\n\n";
		switch (currentTool) {
			case T_PAINKILLER:
				statusMessage = statusmessage.."\cjAnaesthetic\n";
				statusMessage = statusmessage.."\cuFast-acting local painkiller.\n";
				break;
			case T_FORCEPS:
				statusMessage = statusmessage.."\cjForceps\n";
				statusMessage = statusmessage.."\cuPrecision tool for removing obstructions..\n";
				break;
			case T_SALINE:
				statusMessage = statusmessage.."\cjSaline\n";
				statusMessage = statusmessage.."\cuSterile flushing/cleaning solution.\n";
				break;
			case T_BIOFOAM:
				statusMessage = statusmessage.."\cjBiofoam\n";
				statusMessage = statusmessage.."\cuAbsorbant antispetic flesh-analogue.\n";
				break;
			case T_STAPLER:
				statusMessage = statusmessage.."\cjStapler\n";
				statusMessage = statusmessage.."\cuManual hand-stapler.\n";
				break;
			case T_SUTURES:
				statusMessage = statusmessage.."\cjSutures\n";
				statusMessage = statusmessage.."\cuHook needle and biodegradable thread.\n";
				break;
			case T_2F:
				statusMessage = statusmessage.."\cjSecond Flesh\n";
				statusMessage = statusmessage.."\cuAdvanced stem cell and nutrient cocktail.\n";
				break;
		}

		statusMessage = statusMessage.."\n\n\n\n";
		statusMessage = statusMessage.."\crTreating:\n";
		statusMessage = statusMessage..CurrentWound.status;

		// Open Wound
		if ((owner.player.cmd.buttons & BT_ATTACK) && !(owner.player.oldbuttons & BT_ATTACK)) {
			if (currentWound.active) {
				currentWound.size++;
			}
			else if (o.unstablewoundcount > 0) {
				o.A_PlaySound("imp/melee", CHAN_WEAPON, 0.1);
				currentWound.size = min(random(1, 5), o.unstablewoundcount);
				o.unstablewoundcount -= currentWound.size;
				currentWound.active = true;
			}
			currentwound.status = "";
			if (currentWound.size >= 1 && currentWound.size <= 2) { currentwound.status = currentwound.status.."Small"; }
			else if (currentWound.size >= 3 && currentWound.size <= 4) { currentwound.status = currentwound.status.."Moderate"; }
			else if (currentWound.size >= 5) { currentwound.status = currentwound.status.."Large"; }
			if(currentWound.status != "") { currentWound.status = currentwound.status.." wound"; }
		}

		//Debugging
		if ((owner.player.cmd.buttons & BT_USER1) && !(owner.player.oldbuttons & BT_USER1)) { DebugGiveWounds(); }
		DebugStatus();

		A_WeaponMessage(statusMessage);
	}

	void DebugStatus() {
		if (!owner) { return; }
		let ownr = HDPlayerPawn(owner);
		statusMessage = statusMessage.."\n"..currentMessage;
		statusMessage = statusMessage.."Open Wounds "..ownr.woundcount.."\n";
		statusMessage = statusMessage.."Unstable Wounds "..ownr.unstablewoundcount.."\n";
		statusMessage = statusMessage.."Old Wounds "..ownr.oldwoundcount.."\n";
	}
}
*/
