// Searching behavior

extend class UaS_AI_Handler {
	int AIMode;
	int countdown;
	actor lastKnown;
	bool isSearching;

	enum UaS_Nice_AI_Modes {
		mode_normal = 0,
		mode_chasing = 1,
		mode_searching = 2,
	};

	void SearchBehavior() {
		// Return conditions
		if(!UaS_AI_Searching) { return; }
		if(owner.health <= 0) { return; }

		if (owner.target && owner.target.CheckClass("HDPlayerPawn", AAPTR_DEFAULT, true)) {
			countdown = random(30*35, 60*35);
			if (lastknown) { lastKnown.destroy(); }

			if (!owner.CheckIfTargetInLOS() || (owner.target.bShadow && random(0,35) == 0)) {
				isSearching = true;
				lastKnown = actor.spawn("UaS_LastKnownMarker", owner.target.pos, ALLOW_REPLACE);
				lastKnown.angle = owner.angle;
				ForgetTarget(owner);
				owner.goal = lastKnown;
				owner.target = lastKnown;
				if(UaS_Debug & Searching) { A_Log(owner.GetClassName()..score.." lost target!"); }
			}
		}

		if (isSearching && !owner.target) {
			double nextAngle;
			if (lastKnown) {
				nextAngle = lastKnown.angle + random(-90, 90);
				lastKnown.destroy();
			}
			else { nextAngle = random(0, 360); }
			FLineTraceData nextNode;
			owner.LineTrace(nextAngle, 256, 0, TRF_THRUACTORS|TRF_THRUHITSCAN, owner.height/2, data: nextNode);
			lastKnown = actor.spawn("UaS_LastKnownMarker", nextNode.HitLocation, ALLOW_REPLACE);
			lastKnown.angle = nextAngle;
			owner.goal = lastKnown;
			owner.target = lastKnown;
			if(UaS_Debug & Searching) { A_Log(owner.GetClassName()..score.." picked new pathnode."); }
		}

		if (countdown == 0) {
			isSearching = false;
			if (lastknown) { lastKnown.destroy(); }
			if (UaS_Debug & Searching) { A_Log(owner.GetClassName()..score.." gave up the search"); }
		}

		countdown = max(countdown - 1, -1);
		if ((UaS_Debug & Searching) && (countdown % 175 == 1)) { A_Log(owner.GetClassName()..score.." searching for "..(countdown/35)); }
	}

	void ForgetTarget(actor which) {
		// Built-in target-clearing functions
		which.A_ClearTarget();
		which.A_ClearSoundTarget();
		which.A_ClearLastHeard();

		// No idea if this does anything
		which.cursector.SoundTarget = null;

		// May as well go full-retard
		for(int i = 0; i < Level.Sectors.Size(); i++) {
			Level.Sectors[i].SoundTarget = null;
		}

		// Reset to idle/spawn for HD monsters
		if (which.FindState("idle")) { which.SetStateLabel("idle"); }
		else { which.SetStateLabel("spawn"); }

		// Clear HD mob AI goal-setter
		ThinkerIterator mobit = ThinkerIterator.Create("HDMobster");
		Actor currentMobster;
		while (currentMobster = Actor(mobit.Next())) {
			if (currentMobster.master == which) {
				currentMobster.target = null;
			}
		}

		// Debug
		//if(UaS_Debug & Searching) { A_Log(owner.GetClassName()..score.." cleared all target info"); }
	}
}

// Marker for last known position
class UaS_LastKnownMarker : Actor {

	default {
		+NOINTERACTION;
		+FLATSPRITE;
		Radius 1;
		Height 1;
		Health 0;
	}

	states {
	spawn:
		TNT1 A 0 NoDelay {
			SetOrigin((pos.xy, floorz),false);
			if(UaS_Debug & Searching) { sprite = GetSpriteIndex('AMRK'); }
		}
		"####" A 700 BRIGHT;
		stop;
	}
}
