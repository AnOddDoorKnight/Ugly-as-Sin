// Searching behavior

extend class UaS_AI_Handler {
	int AIMode;
	int countdown;
	actor lastKnown;

	enum modes {
		normal = 0,
		chasing = 1,
		searching = 2,
	};

	void SearchBehavior() {
		// Return conditions
		if(!UaS_AI_Searching) { return; }
		if(owner.health <= 0) { return; }
		if (!owner.target) { return; }
		if (!owner.CheckClass("HDPlayerPawn", AAPTR_TARGET, true)) { return; }

		// Testing
		if (owner.target.bShadow || !owner.CheckIfTargetInLOS()) {
			lastKnown = actor.spawn("UaS_LastKnownMarker", owner.target.pos, ALLOW_REPLACE);
			ForgetTarget(owner);
			owner.goal = lastKnown;
			owner.target = lastKnown;
		}
	}

	void ForgetTarget(actor which) {
		// Built-in target-clearing functions
		which.A_ClearTarget();
		which.A_ClearSoundTarget();
		which.A_ClearLastHeard();

		// No idea if this does anything
		which.cursector.SoundTarget = null;

		// May as well go full-retard
		for(int i = 0; i < Level.Sectors.Size(); i++) {
			Level.Sectors[i].SoundTarget = null;
		}

		// Reset to idle/spawn for HD monsters
		if (which.FindState("idle")) { which.SetStateLabel("idle"); }
		else { which.SetStateLabel("spawn"); }

		// Clear HD mob AI goal-setter
		ThinkerIterator mobit = ThinkerIterator.Create("HDMobster");
		Actor currentMobster;
		while (currentMobster = Actor(mobit.Next())) {
			if (currentMobster.master == which) {
				currentMobster.target = null;
			}
		}

		// Debug
		if(UaS_Debug & Searching) { A_Log(owner.GetClassName()..score.." cleared all target info"); }
	}
}

// Marker for last known position
class UaS_LastKnownMarker : Actor {

	default {
		+NOINTERACTION;
		+FLATSPRITE;
		Radius 1;
		Height 1;
		Health 0;
	}

	states {
	spawn:
		TNT1 A 0 NoDelay {
			SetOrigin((pos.xy, floorz),false);
			if(UaS_Debug & Searching) { sprite = GetSpriteIndex('AMRK'); }
		}
		"####" A -1;
		stop;
	}
}
