const UAS_HDLD_STABILZER = "stb";
const UAS_STB_SLOT = 25;

class UaS_GyroStabilizer : HDPickup {
	array<string> weaponList;
	array<int> AttachList;
	string statusText;
	int counter;

	Default {
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Picked up a gyro stabilizer.";
		Inventory.Icon "HSCVI0";
		HDPickup.Bulk 10;
		Scale 0.75;
		tag "Gyroscopic Stabilizer";
		hdpickup.refid UAS_HDLD_STABILZER;
	}

	override void DoEffect() {
		super.DoEffect();
		DoStabilize();
	}

	void DoStabilize() {
		let ownr = HDPlayerPawn(owner);
		if(!ownr) { return; }
		if(!ownr.player.ReadyWeapon) { return; } // Skip if no ready weapon
		HDWeapon wep = HDWeapon(owner.player.ReadyWeapon); // Cast the readyweapon
		if (!(wep is "HDFist") && CheckAttached(wep) >= 0) {
			if(level.maptime % 3 == 0) { counter++; }
			if(level.maptime % 2 == 0) { counter -= min(int(ownr.vel.length()), 1); }
			counter -= ownr.muzzleclimb1.length();
			counter  = clamp(counter, 0, 100);
			if (counter < 10) {
				statusText = "\crCALIBRATING \cu("..random(0,99)..","..random(0,99)..")";
				if (level.maptime % 4 == 0) { statusText = ""; }

			}
			else {
				double maxfactor = max(100 - counter, 25) / 100.0;
				MultiplyRecoil(maxfactor);
				if (counter <= 50) { statusText = "\cqSTABILIZING \cu("..random(counter,100-counter)..","..random(counter,100-counter)..")"; }
				else { statusText = "\cdSTABILIZED \cu"..counter; }
			}
		}
		else {
			statusText = "";
			counter = 0;
		}
	}

	void MultiplyRecoil(double factor) {
		let ownr = HDPlayerPawn(owner);
		if(!ownr) { return; }
		ownr.muzzleclimb1  *= factor;
		ownr.muzzleclimb2  *= factor;
		ownr.muzzleclimb3  *= factor;
		ownr.muzzleclimb4  *= factor;
		ownr.hudbobrecoil1 *= factor;
		ownr.hudbobrecoil2 *= factor;
		ownr.hudbobrecoil3 *= factor;
		ownr.hudbobrecoil4 *= factor;
		ownr.muzzledrift   *= factor;
		if (ownr.scopecamera) {
			ownr.scopecamera.angle *= factor;
			ownr.scopecamera.pitch *= factor;
		}
	}

	override void DrawHudStuff(hdstatusbar sb, hdplayerpawn hpl, int hdflags, int gzflags) {
		sb.drawstring(sb.pnewsmallfont,
			statusText,
			(50,-50),
			flags:sb.DI_TEXT_ALIGN_LEFT|sb.DI_SCREEN_HCENTER|sb.DI_SCREEN_BOTTOM,
			translation:Font.CR_GRAY,scale:(0.5,0.5)
		);
	}

	override bool Use(bool pickup) {
		if(!owner.player.ReadyWeapon) { return false; } // Skip if no ready weapon
		HDWeapon wep = HDWeapon(owner.player.ReadyWeapon); // Cast the readyweapon
		AttachOrDetatch(wep);
		return false;
	}

	void AttachOrDetatch(HDWeapon atdt) {
		int index = CheckAttached(atdt);
		if (index == -1) { AttachToWeapon(atdt); }
		else { DetachFromWeapon(atdt, index); }
	}

	// -1 means not in attach list
	int CheckAttached(HDWeapon cw) {
		int ret = -1;
		for (int i = 0; i < AttachList.size(); i++) {
			if (cw.weaponstatus[UAS_STB_SLOT] == AttachList[i]) {
				ret = i;
				break;
			}
		}
		return ret;
	}

	void DetachFromWeapon(HDWeapon dt, int index = -1) {
		if (index >= 0) {
			dt.weaponstatus[UAS_STB_SLOT] = 0;
			AttachList.delete(index);
			console.printf("Detatched index "..index);
			A_StartSound("misc/fragknock", CHAN_BODY, volume: 0.3);
			statusText = "";
		}
	}

	void AttachToWeapon(HDWeapon at) {
		int UID = random(int.max/4, int.max);
		at.weaponstatus[UAS_STB_SLOT] = UID;
		AttachList.push(UID);
		console.printf("Attached with UID "..UID);
		A_StartSound("misc/fragknock", CHAN_BODY, volume: 0.3);
		A_StartSound("misc/casing", CHAN_WEAPON, volume: 0.3);
		counter = 0;
	}

	States {
		Spawn:
			HSCV I -1;
			stop;
	}
}
