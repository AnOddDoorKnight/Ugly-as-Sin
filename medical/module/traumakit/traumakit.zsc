const UAS_HDLD_TRAUMAKIT = "trk";

class UaS_TraumaKit : HDWeapon {
	string statusMessage;
	StatusInfo currentMessage;
	WoundInfo currentWound;
	UaS_WoundHandler wh;
	HDPlayerPawn patient, lastpatient;
	transient cvar autostrip;

	Default {
		radius 4;
		height 4;
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Picked up a personal trauma kit.";
		Inventory.Icon "UGSIF0";
		Inventory.PickupSound "weapons/pocket";
		+INVENTORY.INVBAR;
		+INVENTORY.PERSISTENTPOWER;
		+INVENTORY.IGNORESKILL;
		+WEAPON.NO_AUTO_SWITCH;
		+hdweapon.fitsinbackpack;
		//+WEAPON.NOAUTOFIRE;
		weapon.slotpriority 0.5;
		weapon.slotnumber 9;
		hdweapon.refid UAS_HDLD_TRAUMAKIT;
		scale 0.5;
		tag "Trauma Kit";
	}

	override double weaponbulk(){
		double b = 0;
		b += (weaponstatus[TKS_PAINKILLER] / 20) * (ENC_STIMPACK * 0.4);
		b += (weaponstatus[TKS_SALINE] / 1000) * (ENC_STIMPACK * 2 * 0.8);
		b += (weaponstatus[TKS_BIOFOAM] / 250) * (6 * 0.6);
		b += (weaponstatus[TKS_STAPLES] / 25) * (6 * 0.1);
		b = max(b, 15);
		return b;
	}

	states {
		spawn:
			UGSI F -1;
			stop;
	}

	override void DoEffect() {
		if (!(owner.player.readyweapon is 'UaS_TraumaKit')) { return; }
		statusMessage = ""; // This is used for tools to display stuff

		SetHelpText();
		SetPatient();
		CycleWounds();
		CycleTools();
		HandleSupplies();

		switch (weaponstatus[TK_SELECTED]) {
			case T_PAINKILLER:
				HandlePainkiller();
				break;
			case T_SALINE:
				HandleSaline();
				break;
			case T_FORCEPS:
				HandleForceps();
				break;
			case T_BIOFOAM:
				HandleBiofoam();
				break;
			case T_STAPLER:
				HandleStapler();
				break;
			case T_SUTURES:
				HandleSutures();
				break;
			case T_SCALPEL:
				HandleScalpel();
				break;
		}

		TickMessages();
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl) {
		if (!patient) return;
		// Floats for precision (also required for centering)
		float textHeight = sb.pSmallFont.mFont.GetHeight();
		float padding = 2;
		float padStep = textHeight + padding;
		float halfStep = padStep / 2;
		float baseOffset = (-7 * textHeight) + (-3 * padding); // Start calculating from center of screen?

		// Header
		sb.DrawString(
			sb.pSmallFont,
			"--- \cyTrauma Kit\c- ---",
			(0, baseOffset),
			sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER,
			Font.CR_GRAY
		);
		sb.DrawString(
			sb.pSmallFont,
			"Treating \cg" .. patient.player.GetUsername(),
			(0, baseOffset + textHeight),
			sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER,
			Font.CR_GRAY
		);

		// Wound List
		int woundListOffsetX = -12;
		float woundListOffsetY = baseOffset + (3 * textHeight) + (3 * padStep);

		if (wh.critWounds.Size() == 0) {
			sb.DrawString(
				sb.pSmallFont,
				"No treatable wounds",
				(0, woundListOffsetY),
				sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER,
				Font.CR_GRAY
			);
		} else {
			Array<string> wounds;
			int idx = (currentWound)? wh.critWounds.Find(currentWound) : 0;
			int loopMin = Min(idx - 2, wh.critWounds.Size() - 5);
			int loopMax = Max(idx + 2, 4);

			// Compile list
			for (int i = loopMin; i <= loopMax; i++) {
				if (i < 0 || i > wh.critWounds.Size() - 1) continue;

				string textColor;
				bool selected = (currentWound && i == idx);
				if (wh.critWounds[i].avgstat >= 15) {
					textColor = (selected)? "\ca" : "\cr"; // Red / Dark Red
				} else {
					textColor = (selected)? "\cd" : "\cq"; // Green / Dark Green
				}

				string pointer = (selected)? " <" : "";
				wounds.push(textColor..wh.critWounds[i].description..pointer);
				woundListOffsetY -= halfStep;
			}
			woundListOffsetY += halfStep; // accommodation

			// Top overflow dot
			if (loopMin > 0) {
				sb.DrawString(
					sb.pSmallFont,
					". . .",
					(woundListOffsetX, woundListOffsetY - padStep),
					sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_RIGHT,
					Font.CR_GRAY
				);
			}

			// The actual list
			for (int i = 0; i < wounds.Size(); i++) {
				sb.DrawString(
					sb.pSmallFont,
					wounds[i],
					(woundListOffsetX, woundListOffsetY),
					sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_RIGHT
				);

				woundListOffsetY += padStep;
			}

			// Bottom overflow dot
			if (loopMax < wh.critWounds.Size() - 1) {
				sb.DrawString(
					sb.pSmallFont,
					". . .",
					(woundListOffsetX, woundListOffsetY),
					sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_RIGHT,
					Font.CR_GRAY
				);
			}
		}

		// Wound info
		int woundInfoOffsetX = 12;
		float woundInfoOffsetY = baseOffset + (3 * textHeight) + (3 * padStep);
		if (currentWound) {
			Array<string> status;

			if (currentWound.open <= 0) {
				status.Push("-The wound is "..GetStatusColor(currentWound.open).."closed\c-.");
			}
			else {
				status.Push("-The wound is "..GetStatusColor(currentWound.open).."open");

				string tmpStr;

				// Painkillers
				tmpStr = "not numbed.";
				if (currentWound.painkiller >= 75) tmpStr = "numbed";
				else if (currentWound.painkiller >= 50) tmpStr = "mostly numbed";
				else if (currentWound.painkiller >= 25) tmpStr = "somewhat numbed";

				status.Push("-It is "..GetStatusColor(100 - currentWound.painkiller)..tmpStr);
				woundInfoOffsetY -= halfStep;

				// Dirty
				if (currentWound.dirty >= 0)
				{
					tmpStr = "completely clean";
					if (currentWound.dirty >= 65) { tmpStr = "filthy"; }
					else if (currentWound.dirty >= 55) { tmpStr = "very dirty"; }
					else if (currentWound.dirty >= 45) { tmpStr = "somewhat dirty"; }
					else if (currentWound.dirty >= 35) { tmpStr = "a bit dirty"; }
					else if (currentWound.dirty >= 25) { tmpStr = "almost clean"; }
					else if (currentWound.dirty >= 15) { tmpStr = "acceptably clean"; }

					status.Push("-It is "..GetStatusColor(currentWound.dirty)..tmpStr);
					woundInfoOffsetY -= halfStep;
				}

				// Obstructions
				if (currentWound.obstructed >= 0)
				{
					tmpStr = "no apparent obstructions";
					if (currentWound.obstructed >= 55) { tmpStr = "many obstructions"; }
					else if (currentWound.obstructed >= 45) { tmpStr = "several obstructions"; }
					else if (currentWound.obstructed >= 35) { tmpStr = "a few obstructions"; }
					else if (currentWound.obstructed >= 25) { tmpStr = "some obstructions"; }
					else if (currentWound.obstructed >= 15) { tmpStr = "very little obstructions"; }

					status.Push("-There are "..GetStatusColor(currentWound.obstructed)..tmpStr);
					woundInfoOffsetY -= halfStep;
				}

				// Cavity
				if (currentWound.cavity >= 0)
				{
					tmpStr = "no treatable tissue damage";
					if (currentWound.cavity >= 85) { tmpStr = "severe tissue damage"; }
					else if (currentWound.cavity >= 65) { tmpStr = "significant tissue damage"; }
					else if (currentWound.cavity >= 45) { tmpStr = "moderate tissue damage"; }
					else if (currentWound.cavity >= 25) { tmpStr = "some tissue damage"; }
					else if (currentWound.cavity >= 15) { tmpStr = "little tissue damage"; }

					status.Push("-There is "..GetStatusColor(currentWound.cavity)..tmpStr);
					woundInfoOffsetY -= halfStep;
				}
			}

			for (int i = 0; i < status.Size(); i++)
			{
				sb.DrawString(
					sb.pSmallFont,
					status[i],
					(woundInfoOffsetX, woundInfoOffsetY),
					sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT,
					Font.CR_GRAY
				);

				woundInfoOffsetY += padStep;
			}
		} else {
			sb.DrawString(
				sb.pSmallFont,
				"-No wounds selected-",
				(woundInfoOffsetX, woundInfoOffsetY),
				sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_LEFT,
				Font.CR_DARKGRAY
			);
		}

		// Tool info
		float toolInfoOffset = baseOffset + (4 * textHeight) + (7 * padStep);
		Array<string> trueStatusMessage;
		statusMessage.Split(trueStatusMessage, "\n"); // it just works

		for (int i = 0; i < trueStatusMessage.Size(); i++) {
			sb.DrawString(
				sb.pSmallFont,
				trueStatusMessage[i],
				(0, toolInfoOffset),
				sb.DI_SCREEN_CENTER | sb.DI_TEXT_ALIGN_CENTER
			);

			toolInfoOffset += textHeight;
		}
	}

	ui string GetStatusColor(int amount) {
		if (amount >= 90) { return "\cm"; } // Black
		if (amount >= 80) { return "\cr"; } // Dark Red
		if (amount >= 70) { return "\ca"; } // Brick
		if (amount >= 60) { return "\cx"; } // Fire
		if (amount >= 50) { return "\ci"; } // Orange
		if (amount >= 40) { return "\ck"; } // Yellow
		if (amount >= 30) { return "\cs"; } // Dark Brown
		if (amount >= 20) { return "\cq"; } // Dark Green
		if (amount >= 10) { return "\cd"; } // Green
		if (amount >= 0) { return "\cd"; } // Grey (wait, isn't this green?)
		return "\cj"; // White
	}

	// Somewhat copied from HD, largely rewritten
	bool HandleStrip() {
		if (!autostrip) { autostrip = CVar.GetCVar("hd_autostrip", owner.player); }
		string itemname, imperative;
		// check for intervening items, otherwise exit early
		bool intervening = !HDPlayerPawn.CheckStrip(patient, patient, false);
		if(!intervening) return true;

		if(patient.countinv("WornRadsuit")) { itemname = "environment suit "; }
		else if(patient.countinv("HDArmourWorn")) { itemname = "armour "; }
		else { itemname = "worn layers "; }

		// check owner or other
		if(patient == owner) {
			imperative = "Take off your ";
			//handle autostrip
			if(autostrip.GetBool()) {
				HDPlayerPawn.CheckStrip(owner, owner);
				return false;
			}
		}
		else {
			imperative = "Have them take off their ";
		}
		// display message
		currentmessage.text = imperative..itemname.."first!\n";
		currentmessage.timeout = 2*35;
		return false;
	}

	void SetPatient() {
		HDPlayerPawn other;
		FLineTraceData tktrace;
		owner.LineTrace(owner.angle, 42, owner.pitch, offsetz: owner.height-12, data: tktrace);
		if (tktrace.hitactor && tktrace.hitactor is "HDPlayerPawn") { other = HDPlayerPawn(tktrace.hitactor); }

		if (other && (owner.player.cmd.buttons & BT_ZOOM)) { patient = other; }
		if (!patient || levellocals.Vec3Diff(owner.pos, patient.pos).length() > owner.radius * 4) { patient = HDPlayerPawn(owner); }

		wh = UaS_WoundHandler(patient.FindInventory('UaS_WoundHandler'));
		if (!wh) { console.printf("No wound handler!"); return; }
		if (patient != lastpatient) { currentWound = null; }
		lastpatient = patient;
	}

	void TickMessages() {
		// Tick down transient messages
		if (currentmessage.timeout > 0) {
			statusmessage = statusmessage..currentmessage.text;
			currentmessage.timeout--;
		}
	}

	void CycleWounds() {
		if (wh.critwounds.size() == 0) { return; }
		int idx = 0;
		if (currentWound) { idx = wh.critwounds.Find(currentWound); }
		if (!(owner.player.cmd.buttons & BT_FIREMODE)) { return; }
		if ((owner.player.cmd.buttons & BT_RELOAD) && !(owner.player.oldbuttons & BT_RELOAD)) {
			idx = (idx + 1) % wh.critwounds.size();
		}
		else if ((owner.player.cmd.buttons & BT_ALTRELOAD) && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			idx = (idx - 1) % wh.critwounds.size();
			if(idx < 0) { idx = wh.critwounds.size() - 1; }
		}
		currentWound = GetWound(idx);
	}

	void CycleTools(int set = -1) {
		if ((owner.player.cmd.buttons & BT_FIREMODE)) { return; }
		if (set != -1) { weaponstatus[TK_SELECTED] = set; return; }
		if ((owner.player.cmd.buttons & BT_RELOAD) && !(owner.player.oldbuttons & BT_RELOAD)) {
			weaponstatus[TK_SELECTED] = (weaponstatus[TK_SELECTED] + 1) % 7;
			weaponstatus[TK_HOLD] = 0;
			currentmessage.text = "";
			currentmessage.timeout = 0;
		}
		else if ((owner.player.cmd.buttons & BT_ALTRELOAD) && !(owner.player.oldbuttons & BT_ALTRELOAD)) {
			weaponstatus[TK_SELECTED] = (weaponstatus[TK_SELECTED] - 1);
			if(weaponstatus[TK_SELECTED] < 0) { weaponstatus[TK_SELECTED] = 6; }
			weaponstatus[TK_HOLD] = 0;
			currentmessage.text = "";
			currentmessage.timeout = 0;
		}
	}

	WoundInfo GetWound(int index) {
		if (wh.critwounds.size() <= 0) { return null; }
		return wh.critwounds[index];
	}

	void DebugStatus() {
		if (currentWound) {
			statusmessage = statusmessage.."dirty "..currentWound.dirty.."\n";
			statusmessage = statusmessage.."obstructed "..currentWound.obstructed.."\n";
			statusmessage = statusmessage.."open "..currentWound.open.."\n";
			statusmessage = statusmessage.."cavity "..currentWound.cavity.."\n";
			statusmessage = statusmessage.."infection "..currentWound.infection.."\n";
			statusmessage = statusmessage.."timer "..currentWound.timer.."\n";
		}
		statusMessage = statusMessage.."\n";
		statusMessage = statusMessage.."Open Wounds "..patient.woundcount.."\n";
		statusMessage = statusMessage.."Unstable Wounds "..patient.unstablewoundcount.."\n";
		statusMessage = statusMessage.."Old Wounds "..patient.oldwoundcount.."\n";
	}

	struct StatusInfo {
		string text;
		int timeout;
	}

	enum ToolModes {
		T_PAINKILLER,
		T_SALINE,
		T_FORCEPS,
		T_BIOFOAM,
		T_STAPLER,
		T_SUTURES,
		T_SCALPEL,
	}

	enum KitFlags {
		//standard slots
		TK_SELECTED,
		TK_BUTTON,
		TK_HOLD,
		TK_SCALPEL_CAP,

		//supply slots
		TKS_PAINKILLER,
		TKS_SALINE,
		TKS_BIOFOAM,
		TKS_STAPLES,
	}
}
