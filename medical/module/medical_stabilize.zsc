/// <summary>
/// This is a tool for all HD Players to 'compress' bandaged wounds to turn
/// from temporarily healed to as a regular medkit when its not accessible so
/// players wont just start randomly bleeding for the 4965th time because they
/// walked a bit too hard.
/// </summary>
class UaS_WoundStabilization : HDWoundFixer 
{
	string lastUser;
	
	// The amount of pressure the player forces on the wound to convert treated to sealed
	int pressure;
	// current delay between ticks when the pressure decreases by 1
	int brace;
	// maximum delay between ticks when the pressure decreases by 1, inclusive
	int maxBrace;

	// how much 'charge' the player has during the pressure process.
	int pressureCharge;
	// current delay between ticks when the charge decreases by 1, inclusive
	int chargeBrace;
	// maximum delay between ticks when the pressure decreases by 1
	int maxChargeBrace;
	default
	{
		+hdweapon.dontdisarm
		weapon.selectionorder 1003;
		weapon.slotpriority 0.6;
		weapon.slotnumber 9;
		
		// Probably could remove these, this is borrowed from selfbandage class 
		// - and tacked on this to ensure stability
		Inventory.Amount 1;
		Inventory.MaxAmount 1;
		Inventory.PickupMessage "Got!";
		//+INVENTORY.PERSISTENTPOWER;
		//+INVENTORY.IGNORESKILL;
		-HDWEAPON.FITSINBACKPACK;
		-INVENTORY.INVBAR;
		tag "Wound Stabilization";
	}

	override double weaponbulk()
	{ 
		return 0; 
	}

	override void InitializeWepStats(bool idfa)
	{
		pressure = 0;
		brace = 0;
		maxBrace = 1;
		pressureCharge = 0;
		chargeBrace = 0;
		maxChargeBrace = 3;
		previousStatus = false;
		lastUser = "null";
	}

	override void Tick()
	{
		//targetwound = hdbleedingwound.findbiggest(self, 1);
		// Does ticking behaviour
		bool canStabilizeBandages = CanStabilizeBandages();
		if (canStabilizeBandages)
		{
			// Brace
			brace += 1;
			if (brace > maxBrace)
			{
				brace = 0;
				ModifyPressure(-1);
			}
			// Charge
			chargeBrace += 1;
			if (chargeBrace > maxChargeBrace)
			{
				chargeBrace = 0;
				ModifyCharge(-1);
			}
		}
		else
		{
			pressure = 0;
			pressureCharge = 0;
		}
		
		if (pressure > 0)
			console.printf("Pressure: "..pressure.." ---- Charge: "..pressureCharge);
		
		// Status Message
		string statusMessage = "--- \cdWound stabilization\c- ---\n";
		if (lastUser != "null")
		{
			statusmessage.AppendFormat("Treating \cg"..lastUser.."\n\n");
		}
		else
		{
			statusmessage.AppendFormat("\n\n");
		}
		statusMessage.AppendFormat("\cuApply pressure and\nhemostatic compound\nto bandaged wounds.\n\n\n");
		if (!canStabilizeBandages)
		{
			statusMessage.AppendFormat("No unstable bandaged wounds to treat.");
		}
		else
		{
			statusMessage.AppendFormat(ToPressureString());
		}
		A_WeaponMessage(statusMessage);
	}



	override string GetHelpText()
	{
		string output;
			output.AppendFormat(WEPHELP_FIRE.."  Hold to apply pressure\n");
			//output.AppendFormat(WEPHELP_RELOAD.."  Hold to apply hemostatics\n");
			//output.AppendFormat(WEPHELP_ZOOM.."  Treat another player\n");
			return output;
	}

	// Copied from selfbandage
	override inventory CreateTossable(int amt)
	{
		DropMeds(owner, 0);
		return null;
	}

	void ModifyPressure(int amount)
	{
		pressure += amount;
		// Clamping vlaues
		if (pressure < 0)
			pressure = 0;
		else if (pressure > 100)
			pressure = 100;
	}
	string ToPressureString()
	{
		string bars = "";
		for (int i = 0; i < (pressure + 2) / 10; i++)
		{
			bars.AppendFormat("=");
		}
		return bars.."PRESSURE"..bars;
	}
	void ModifyCharge(int amount)
	{
		pressureCharge += amount;
		// Clamping vlaues
		if (pressureCharge < 0)
			pressureCharge = 0;
		else if (pressureCharge > 100)
			pressureCharge = 100;
	}


	/// <summary>
	/// Shows the wound stabilization window for the user, and calls methods relating
	/// to player actions.
	/// </summary>
	//override void DoEffect() {
	//	if (!(owner.player.readyweapon is 'UaS_WoundStabilization')) { return; }
	//	SetHelpText();
//
	//	statusMessage = "--- \cdWound stabilization\c- ---\n";
	//	if (patient) 
	//	{ 
	//		statusMessage = statusmessage.."Treating \cg"..patient.player.getusername().."\n\n"; 
	//		}
	//	else 
	//	{ 
	//		statusMessage = statusmessage.."\n\n"; 
	//	}
//
	//	statusMessage = statusmessage..
	//		"\cuApply pressure and\nhemostatic compound\nto bandaged wounds.\n\n\n";
//
	//	BleedingControl();
	//	TickMessages();
	//	A_WeaponMessage(statusMessage);
	//}

	//void BleedingControl() {
	//	SetPatient();
	//	if (patient.unstablewoundcount <= 0) {
	//		currentmessage.text = "";
	//		statusMessage = statusmessage.."No unstable bandaged wounds to treat.";
	//		hemostatic = 0;
	//		pressure = 0;
	//		return;
	//	}
//
	//	// Hemostatic amount readout
	//	if (hemostatic > 0) { statusMessage = statusmessage.."\ca"; }
	//	for (int i = 0; i < hemostatic; i++) { statusmessage = statusmessage.."="; }
	//	statusmessage = statusmessage.."Hemostatic";
	//	for (int i = 0; i < hemostatic; i++) { statusmessage = statusmessage.."="; }
	//	statusmessage = statusmessage.."\n";
//
	//	// Pressure amount readout
	//	if (pressure > 50) { statusMessage = statusmessage.."\cw"; }
	//	if (pressure > 100) { statusMessage = statusmessage.."\cm"; }
	//	for (int i = 0; i < pressure/10; i++) { statusmessage = statusmessage.."="; }
	//	statusmessage = statusmessage.."Pressure";
	//	for (int i = 0; i < pressure/10; i++) { statusmessage = statusmessage.."="; }
	//	statusmessage = statusmessage.."\n\n";

		// Apply hemostatic compound
		//if ((owner.player.cmd.buttons & BT_RELOAD)) {
		//	pressure = 0;
		//	if (hemostatic >= 5) {
		//		currentmessage.text = "Applied hemostatic compound.\n"
		//			.."\cr--WARNING--\n"
		//			.."Clotting agents can cause\n"
		//			.."burns and tissue damage!\n";
		//		currentmessage.timeout = 35;
		//		return;
		//	}
		//	else {
		//		if (!(owner.player.oldbuttons & BT_RELOAD)) { owner.A_StartSound("bandage/rip", CHAN_WEAPON, CHANF_DEFAULT, 0.5); }
		//		if (level.time % 20 == 0) {
		//			owner.A_StartSound("misc/wallchunks",CHAN_WEAPON);
		//			HDPlayerPawn(owner).A_MuzzleClimb(
		//				(frandom[uas_bc](-1,1),frandom[uas_bc](0,1))/2,
		//				(frandom[uas_bc](-1,1),frandom[uas_bc](0,1))/2,
		//				(frandom[uas_bc](-1,1),frandom[uas_bc](0,1))/2,
		//				(frandom[uas_bc](-1,1),frandom[uas_bc](0,1))/2
		//			);
		//			hemostatic++;
		//			currentmessage.text = "Applying hemostatic compound to wound.\n"
		//				.."\cr--WARNING--\n"
		//				.."Clotting agents can cause\n"
		//				.."burns and tissue damage!\n";
		//			currentmessage.timeout = 35;
		//		}
		//		return;
		//	}
		//}

		// Apply pressure
	//	double shake;
	//	if ((owner.player.cmd.buttons & BT_ATTACK)) {
	//		pressure = min(pressure + 1, 99 + (hemostatic * 10));
	//		shake = pressure / 20.0;
	//		if (random[uas_bc](0,25) == 0) { patient.A_StartSound("misc/smallslop", CHAN_BODY); }
	//		if (pressure == 100) {
	//			patient.damagemobj(owner,owner,1,"staples");
	//			patient.burncount += randompick[uas_bc](0, 0, 0, 1);
	//		}
	//		if (pressure == 109) {
	//			pressure = 0;
	//			patient.damagemobj(owner,owner,1,"staples");
	//			patient.burncount += randompick[uas_bc](0, 1);
	//		}
	//	}
	//	else {
	//		pressure = max(pressure - 1, 0);
	//		shake = -pressure / 20.0;
	//	}
//
	//	// Shake and fluctuate view
	//	HDPlayerPawn(owner).A_MuzzleClimb(
	//		(frandom[uas_bc](-shake,shake),frandom[uas_bc](0,shake))/20,
	//		(frandom[uas_bc](-shake,shake),frandom[uas_bc](0,shake))/30,
	//		(frandom[uas_bc](-shake,shake),frandom[uas_bc](0,shake))/40,
	//		(frandom[uas_bc](-shake,shake),frandom[uas_bc](0,shake))/50
	//	);
//
	//	// check for stopped bleeding
	//	bool canstabilize = (
	//		(hemostatic <= 0) ||
	//		(hemostatic > 0 && pressure <= 100)
	//	);
	//	if (level.time % 10 == 0 && canstabilize) {
	//		int upperlimit = pressure + (hemostatic * 10);
	//		int check = (
	//			random[uas_bc](0, upperlimit) +
	//			random[uas_bc](0, upperlimit)) / 2;
//
	//		if (check > 70) {
	//			currentmessage.text = "Stabilized some bleeding.";
	//			currentmessage.timeout = 35;
	//			hemostatic = max(hemostatic - 1, 0);
	//			pressure = 50;
	//			patient.unstablewoundcount = max(patient.unstablewoundcount - 1, 0);
	//			patient.oldwoundcount = max(patient.oldwoundcount + 1, 0);
	//		}
	//	}
	//}

	//struct StatusInfo {
	//	string text;
	//	int timeout;
	//}
	
	void ShootWoundStabilizer()
	{
		
	}

	//void TickMessages() {
	//	// Tick down transient messages
	//	if (currentmessage.timeout > 0) {
	//		statusmessage = statusmessage..currentmessage.text;
	//		currentmessage.timeout--;
	//	}
	//}

	/// <summary>
	/// Finds the amount of wounds first hand, then determines if it should
	/// handle those wounds based on individual stats; The 'temporarily bandaged'
	/// stat.
	/// </summary>
	action bool CanStabilizeBandages()
	{
		//invoker.targetwound = HDBleedingWound.findbiggest(invoker);
		bool output = invoker.targetwound;
		if (output != invoker.previousStatus)
			console.printf((invoker.targetwound ? "There is a wound to patch!" : "Nvm it gone"));
		invoker.previousStatus = output;
		return output;
	}
	bool previousStatus;

	clearscope static HDBleedingWound FindBiggestPatched(actor bleeder)
	{
		double deepest = 0;
		HDBleedingWound bldwres=null;
		HDBleedingWound bldw=null;
		thinkeriterator bldit = thinkeriterator.create("HDBleedingWound");
		while(bldw = HDBleedingWound(bldit.next())){
			if (!bldw) 
				continue;
			double deep = bldw.patched;
			if(bldw.bleeder==bleeder && deepest < deep)
			{
				deepest=deep;
				bldwres=bldw;
			}
		}
		return bldwres;
	}

	/// <summary>
	/// Determines if the healing process should abort. This is for environmental
	/// factors such as walking.
	/// </summary>
	bool ShouldAbort()
	{
		return false;
	}
	
	states
	{
		select: // Targeting itself
			//invoker.targetwound = null;
			TNT1 A 0
			{
				invoker.lastUser = self.player.getusername();
				//invoker.lastUser = self.wound;

				//invoker.hdbleedingwound = hdbleedingwound;
				//console.printf("Hello, World!");
				//PlayerPawn pawn = PlayerPawn(invoker);
				//string pawnName = pawn.player.GetUserName();
				//invoker.lastUser = pawnName;
				//console.printf(pawnName);
				//invoker.lastUser = pawn.player.getusername();
				//invoker.lastUser = "NAME";//invoker.getusername();
			}
			goto super::select;
		ready:
			TNT1 A 1
			{
				A_WeaponReady(WRF_NOFIRE|WRF_ALLOWUSER1|WRF_ALLOWUSER3);
				invoker.targetwound = FindBiggestPatched(self);
				int button = self.player.cmd.buttons;

				// Blocks pathway to wait until player presses fire
				if (!(button & (BT_ATTACK)))
				{
					return;
				}
				// Blocks path when the player wears something like the radsuit
				let blockinv = HDWoundFixer.CheckCovered(self, CHECKCOV_ONLYFULL);
				if (blockinv)
				{
					A_TakeOffFirst(blockinv.gettag());
					setweaponstate("nope");
					return;
				}
				setweaponstate("fire");
			}
			goto readyend;
		fire:
		hold:
		//lower:
			TNT1 A 0
			{
				console.printf("bruh");
			}
			TNT1 A 0 A_JumpIf(invoker.ShouldAbort() || !invoker.CanStabilizeBandages(), "nope");
			//TNT1 A 0 A_JumpIf(!invoker.CanStabilizeBandages(), "noWounds");
			//TNT1 A 0 A_JumpIf(pitch>45,"try");
			//TNT1 A 1 A_MuzzleClimb(0,6);
			//TNT1 A 0 A_Refire("hold");
			goto try;
		try:
			TNT1 A 1
			{ 
				invoker.ModifyPressure(2);
				if (invoker.pressure >= random(25, 150))
				{
					invoker.ModifyCharge(2);
					console.printf(invoker.pressure.."");
				}
				// Stabilize bandages.
				if (invoker.pressureCharge > 70)
				{
					invoker.pressureCharge = 0;
					invoker.pressure = 50;
					float randomHeal = frandom(0.5, 1.5);
					invoker.targetwound.patch(randomHeal, true);
				}
			}
			goto ready;
		spawn:
			TNT1 A 1;
			stop;
		//noWounds:
		//	TNT1 A 0 
		//	{
		//		invoker.noWoundErrorTimer = 60;
		//	}
		//	goto nope;
		nope:
			goto super::nope;
	}
}
